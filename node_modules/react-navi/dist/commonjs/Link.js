"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __importStar(require("react"));
var navi_1 = require("navi");
var NaviContext_1 = require("./NaviContext");
var HashScroll_1 = require("./HashScroll");
function isExternalHref(href) {
    // If this is an external link, return undefined so that the native
    // response will be used.
    return (!href ||
        (typeof href === 'string' &&
            (href.indexOf('://') !== -1 || href.indexOf('mailto:') === 0)));
}
function getLinkURL(href, routeURL) {
    if (!isExternalHref(href)) {
        // Resolve relative to the current "directory"
        if (routeURL && typeof href === 'string') {
            href = href[0] === '/' ? href : navi_1.joinPaths('/', routeURL.pathname, href);
        }
        return navi_1.createURLDescriptor(href);
    }
}
/**
 * Returns a boolean that indicates whether the user is currently
 * viewing the specified href.
 * @param href
 * @param options.exact If false, will match any URL underneath this href
 * @param options.loading If true, will match even if the route is currently loading
 */
exports.useActive = function (href, _a) {
    var _b = _a === void 0 ? {} : _a, _c = _b.exact, exact = _c === void 0 ? true : _c, _d = _b.loading, loading = _d === void 0 ? false : _d;
    var context = React.useContext(NaviContext_1.NaviContext);
    var route = loading
        ? context.busyRoute || context.steadyRoute
        : context.steadyRoute || context.busyRoute;
    var routeURL = route && route.url;
    var linkURL = getLinkURL(href, routeURL);
    return !!(linkURL &&
        routeURL &&
        (exact
            ? linkURL.pathname === routeURL.pathname
            : navi_1.modifyTrailingSlash(routeURL.pathname, 'add').indexOf(linkURL.pathname) === 0));
};
exports.useLinkProps = function (_a) {
    var disabled = _a.disabled, hashScrollBehavior = _a.hashScrollBehavior, href = _a.href, prefetch = _a.prefetch, target = _a.target, onClick = _a.onClick, rest = __rest(_a, ["disabled", "hashScrollBehavior", "href", "prefetch", "target", "onClick"]);
    var hashScrollBehaviorFromContext = React.useContext(HashScroll_1.HashScrollContext);
    var context = React.useContext(NaviContext_1.NaviContext);
    var navigation = context.navigation;
    if (hashScrollBehavior === undefined) {
        hashScrollBehavior = hashScrollBehaviorFromContext;
    }
    var route = context.steadyRoute || context.busyRoute;
    var routeURL = route && route.url;
    var linkURL = getLinkURL(href, routeURL);
    if (!isExternalHref(href)) {
        var resolvedHref = href;
        // Resolve relative to the current "directory"
        if (routeURL && typeof href === 'string') {
            resolvedHref =
                href[0] === '/' ? href : navi_1.joinPaths('/', routeURL.pathname, href);
        }
        linkURL = navi_1.createURLDescriptor(resolvedHref);
    }
    // Prefetch on mount if required, or if `prefetch` becomes `true`.
    React.useEffect(function () {
        if (prefetch && navigation && linkURL && linkURL.pathname) {
            navigation.prefetch(linkURL).catch(function (e) {
                console.warn("A <Link> tried to prefetch \"" + linkURL.pathname + "\", but the " +
                    "router was unable to fetch this path.");
            });
        }
    }, [navigation, prefetch, linkURL && linkURL.href]);
    var handleClick = React.useCallback(function (event) {
        // Let the browser handle the event directly if:
        // - The user used the middle/right mouse button
        // - The user was holding a modifier key
        // - A `target` property is set (which may cause the browser to open the
        //   link in another tab)
        if (event.button === 0 &&
            !(event.altKey || event.ctrlKey || event.metaKey || event.shiftKey)) {
            if (disabled) {
                event.preventDefault();
                return;
            }
            if (onClick) {
                onClick(event);
            }
            // Let the browser handle targets natively
            if (target) {
                return;
            }
            // Sanity check
            if (!routeURL) {
                return;
            }
            if (!event.defaultPrevented && linkURL) {
                event.preventDefault();
                var isSamePathname = navi_1.modifyTrailingSlash(linkURL.pathname, 'remove') ===
                    navi_1.modifyTrailingSlash(routeURL.pathname, 'remove');
                navigation.navigate(linkURL);
                if ((isSamePathname || linkURL.pathname === '') &&
                    linkURL.hash === routeURL.hash &&
                    linkURL.hash) {
                    HashScroll_1.scrollToHash(routeURL.hash, hashScrollBehavior);
                }
            }
        }
    }, [
        disabled,
        onClick,
        target,
        linkURL && linkURL.href,
        routeURL && routeURL.href,
    ]);
    return __assign({ disabled: disabled, onClick: handleClick, href: linkURL ? linkURL.href : href }, rest);
};
exports.LinkContext = React.createContext(undefined);
var LinkAnchor = /** @class */ (function (_super) {
    __extends(LinkAnchor, _super);
    function LinkAnchor(props) {
        var _this = _super.call(this, props) || this;
        _this.renderChildren = function (context) {
            var _a = _this.props, fromDefaultRenderer = _a.fromDefaultRenderer, props = __rest(_a, ["fromDefaultRenderer"]);
            var handleClick = context.onClick;
            if (_this.props.onClick) {
                handleClick = function (e) {
                    _this.props.onClick(e);
                    if (!e.defaultPrevented) {
                        context.onClick(e);
                    }
                };
            }
            return React.createElement("a", __assign({}, context, props, { onClick: handleClick }));
        };
        if (process.env.NODE_ENV !== 'production') {
            if (!props.fromDefaultRenderer) {
                console.warn("Deprecation Warning: \"<LinkAnchor>\" is deprecated. From Navi 0.14, " +
                    "you'll need to use the \"useLinkProps()\" and \"useActive()\" hooks instead.");
            }
        }
        return _this;
    }
    LinkAnchor.prototype.render = function () {
        return React.createElement(exports.LinkContext.Consumer, { children: this.renderChildren });
    };
    return LinkAnchor;
}(React.Component));
exports.LinkAnchor = LinkAnchor;
// Need to include this type definition, as the automatically generated one
// is incompatible with some versions of the react typings.
exports.Link = Object.assign(React.forwardRef(function (props, anchorRef) {
    var active = props.active, activeClassName = props.activeClassName, activeStyle = props.activeStyle, children = props.children, exact = props.exact, hashScrollBehavior = props.hashScrollBehavior, href = props.href, onClick = props.onClick, prefetch = props.prefetch, render = props.render, rest = __rest(props, ["active", "activeClassName", "activeStyle", "children", "exact", "hashScrollBehavior", "href", "onClick", "prefetch", "render"]);
    var linkProps = exports.useLinkProps({
        hashScrollBehavior: hashScrollBehavior,
        href: href,
        onClick: onClick,
        prefetch: prefetch,
    });
    var actualActive = exports.useActive(href, { exact: !!exact });
    if (active === undefined) {
        active = actualActive;
    }
    var context = __assign({ children: children }, rest, linkProps, { ref: anchorRef });
    React.useEffect(function () {
        if (process.env.NODE_ENV !== 'production') {
            if (render !== defaultLinkRenderer) {
                console.warn("Deprecation Warning: Passing a \"render\" prop to \"<Link>\" is deprecated. From Navi 0.14, " +
                    "you'll need to use the \"useLinkProps()\" and \"useActive()\" hooks instead.");
            }
        }
    }, [render]);
    return (React.createElement(exports.LinkContext.Provider, { value: context }, render({
        active: active,
        activeClassName: props.activeClassName,
        activeStyle: props.activeStyle,
        anchorProps: context,
        children: props.children,
        className: props.className,
        disabled: props.disabled,
        tabIndex: props.tabIndex,
        hidden: props.hidden,
        href: linkProps.href,
        id: props.id,
        lang: props.lang,
        style: props.style,
        target: props.target,
        title: props.title,
        onClick: linkProps.onClick,
    })));
}), { Anchor: LinkAnchor });
function defaultLinkRenderer(props) {
    var active = props.active, activeClassName = props.activeClassName, activeStyle = props.activeStyle, children = props.children, className = props.className, hidden = props.hidden, style = props.style;
    return (React.createElement(LinkAnchor, { children: children, className: (className || '') + " " + ((active && activeClassName) || ''), hidden: hidden, style: Object.assign({}, style, active ? activeStyle : {}), fromDefaultRenderer: true }));
}
exports.Link.defaultProps = {
    render: defaultLinkRenderer,
};
//# sourceMappingURL=Link.js.map